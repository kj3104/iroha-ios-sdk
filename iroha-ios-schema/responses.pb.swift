// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: responses.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// *** WSV data structure *** //
struct Iroha_Protocol_Asset: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Asset"

  var assetID: String = String()

  var domainID: String = String()

  var precision: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.assetID)
      case 2: try decoder.decodeSingularStringField(value: &self.domainID)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.precision)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetID, fieldNumber: 1)
    }
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 2)
    }
    if self.precision != 0 {
      try visitor.visitSingularUInt32Field(value: self.precision, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Iroha_Protocol_Account: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Account"

  var accountID: String = String()

  var domainID: String = String()

  var quorum: UInt32 = 0

  var jsonData: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.accountID)
      case 2: try decoder.decodeSingularStringField(value: &self.domainID)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.quorum)
      case 4: try decoder.decodeSingularStringField(value: &self.jsonData)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 2)
    }
    if self.quorum != 0 {
      try visitor.visitSingularUInt32Field(value: self.quorum, fieldNumber: 3)
    }
    if !self.jsonData.isEmpty {
      try visitor.visitSingularStringField(value: self.jsonData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Iroha_Protocol_AccountAsset: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".AccountAsset"

  var assetID: String {
    get {return _storage._assetID}
    set {_uniqueStorage()._assetID = newValue}
  }

  var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  var balance: Iroha_Protocol_Amount {
    get {return _storage._balance ?? Iroha_Protocol_Amount()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  mutating func clearBalance() {_storage._balance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._assetID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._accountID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._balance)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._assetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetID, fieldNumber: 1)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 2)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// *** Responses *** //
struct Iroha_Protocol_AccountAssetResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".AccountAssetResponse"

  var accountAsset: Iroha_Protocol_AccountAsset {
    get {return _storage._accountAsset ?? Iroha_Protocol_AccountAsset()}
    set {_uniqueStorage()._accountAsset = newValue}
  }
  /// Returns true if `accountAsset` has been explicitly set.
  var hasAccountAsset: Bool {return _storage._accountAsset != nil}
  /// Clears the value of `accountAsset`. Subsequent reads from it will return its default value.
  mutating func clearAccountAsset() {_storage._accountAsset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accountAsset)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountAsset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_AccountDetailResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".AccountDetailResponse"

  var detail: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.detail)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.detail.isEmpty {
      try visitor.visitSingularStringField(value: self.detail, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Iroha_Protocol_AccountResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".AccountResponse"

  var account: Iroha_Protocol_Account {
    get {return _storage._account ?? Iroha_Protocol_Account()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_storage._account = nil}

  var accountRoles: [String] {
    get {return _storage._accountRoles}
    set {_uniqueStorage()._accountRoles = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._accountRoles)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._accountRoles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._accountRoles, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_AssetResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".AssetResponse"

  var asset: Iroha_Protocol_Asset {
    get {return _storage._asset ?? Iroha_Protocol_Asset()}
    set {_uniqueStorage()._asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  var hasAsset: Bool {return _storage._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  mutating func clearAsset() {_storage._asset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._asset)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._asset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iroha_Protocol_RolesResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".RolesResponse"

  var roles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.roles)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Iroha_Protocol_RolePermissionsResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".RolePermissionsResponse"

  var permissions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.permissions)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.permissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Iroha_Protocol_ErrorResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".ErrorResponse"

  var reason: Iroha_Protocol_ErrorResponse.Reason = .statelessInvalid

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Reason: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case statelessInvalid // = 0
    case statefulInvalid // = 1

    /// when requested account does not exist
    case noAccount // = 2

    /// when requested account asset does not exist
    case noAccountAssets // = 3

    /// when requested account detail does not exist
    case noAccountDetail // = 4

    /// when requested signatories does not exist
    case noSignatories // = 5

    /// when unidentified request was received
    case notSupported // = 6

    /// when json format wrong
    case wrongFormat // = 7

    /// when requested asset does not exist
    case noAsset // = 8

    /// when there are no roles defined in the system
    case noRoles // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .statelessInvalid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .statelessInvalid
      case 1: self = .statefulInvalid
      case 2: self = .noAccount
      case 3: self = .noAccountAssets
      case 4: self = .noAccountDetail
      case 5: self = .noSignatories
      case 6: self = .notSupported
      case 7: self = .wrongFormat
      case 8: self = .noAsset
      case 9: self = .noRoles
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .statelessInvalid: return 0
      case .statefulInvalid: return 1
      case .noAccount: return 2
      case .noAccountAssets: return 3
      case .noAccountDetail: return 4
      case .noSignatories: return 5
      case .notSupported: return 6
      case .wrongFormat: return 7
      case .noAsset: return 8
      case .noRoles: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .statelessInvalid {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Iroha_Protocol_SignatoriesResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".SignatoriesResponse"

  var keys: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.keys)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Iroha_Protocol_TransactionsResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TransactionsResponse"

  var transactions: [Iroha_Protocol_Transaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Iroha_Protocol_QueryResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".QueryResponse"

  var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  var accountAssetsResponse: Iroha_Protocol_AccountAssetResponse {
    get {
      if case .accountAssetsResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_AccountAssetResponse()
    }
    set {_uniqueStorage()._response = .accountAssetsResponse(newValue)}
  }

  var accountDetailResponse: Iroha_Protocol_AccountDetailResponse {
    get {
      if case .accountDetailResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_AccountDetailResponse()
    }
    set {_uniqueStorage()._response = .accountDetailResponse(newValue)}
  }

  var accountResponse: Iroha_Protocol_AccountResponse {
    get {
      if case .accountResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_AccountResponse()
    }
    set {_uniqueStorage()._response = .accountResponse(newValue)}
  }

  var errorResponse: Iroha_Protocol_ErrorResponse {
    get {
      if case .errorResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_ErrorResponse()
    }
    set {_uniqueStorage()._response = .errorResponse(newValue)}
  }

  var signatoriesResponse: Iroha_Protocol_SignatoriesResponse {
    get {
      if case .signatoriesResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_SignatoriesResponse()
    }
    set {_uniqueStorage()._response = .signatoriesResponse(newValue)}
  }

  var transactionsResponse: Iroha_Protocol_TransactionsResponse {
    get {
      if case .transactionsResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_TransactionsResponse()
    }
    set {_uniqueStorage()._response = .transactionsResponse(newValue)}
  }

  var assetResponse: Iroha_Protocol_AssetResponse {
    get {
      if case .assetResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_AssetResponse()
    }
    set {_uniqueStorage()._response = .assetResponse(newValue)}
  }

  var rolesResponse: Iroha_Protocol_RolesResponse {
    get {
      if case .rolesResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_RolesResponse()
    }
    set {_uniqueStorage()._response = .rolesResponse(newValue)}
  }

  var rolePermissionsResponse: Iroha_Protocol_RolePermissionsResponse {
    get {
      if case .rolePermissionsResponse(let v)? = _storage._response {return v}
      return Iroha_Protocol_RolePermissionsResponse()
    }
    set {_uniqueStorage()._response = .rolePermissionsResponse(newValue)}
  }

  var queryHash: Data {
    get {return _storage._queryHash}
    set {_uniqueStorage()._queryHash = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case accountAssetsResponse(Iroha_Protocol_AccountAssetResponse)
    case accountDetailResponse(Iroha_Protocol_AccountDetailResponse)
    case accountResponse(Iroha_Protocol_AccountResponse)
    case errorResponse(Iroha_Protocol_ErrorResponse)
    case signatoriesResponse(Iroha_Protocol_SignatoriesResponse)
    case transactionsResponse(Iroha_Protocol_TransactionsResponse)
    case assetResponse(Iroha_Protocol_AssetResponse)
    case rolesResponse(Iroha_Protocol_RolesResponse)
    case rolePermissionsResponse(Iroha_Protocol_RolePermissionsResponse)

    static func ==(lhs: Iroha_Protocol_QueryResponse.OneOf_Response, rhs: Iroha_Protocol_QueryResponse.OneOf_Response) -> Bool {
      switch (lhs, rhs) {
      case (.accountAssetsResponse(let l), .accountAssetsResponse(let r)): return l == r
      case (.accountDetailResponse(let l), .accountDetailResponse(let r)): return l == r
      case (.accountResponse(let l), .accountResponse(let r)): return l == r
      case (.errorResponse(let l), .errorResponse(let r)): return l == r
      case (.signatoriesResponse(let l), .signatoriesResponse(let r)): return l == r
      case (.transactionsResponse(let l), .transactionsResponse(let r)): return l == r
      case (.assetResponse(let l), .assetResponse(let r)): return l == r
      case (.rolesResponse(let l), .rolesResponse(let r)): return l == r
      case (.rolePermissionsResponse(let l), .rolePermissionsResponse(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Iroha_Protocol_AccountAssetResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .accountAssetsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .accountAssetsResponse(v)}
        case 2:
          var v: Iroha_Protocol_AccountDetailResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .accountDetailResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .accountDetailResponse(v)}
        case 3:
          var v: Iroha_Protocol_AccountResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .accountResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .accountResponse(v)}
        case 4:
          var v: Iroha_Protocol_ErrorResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .errorResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .errorResponse(v)}
        case 5:
          var v: Iroha_Protocol_SignatoriesResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .signatoriesResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .signatoriesResponse(v)}
        case 6:
          var v: Iroha_Protocol_TransactionsResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .transactionsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .transactionsResponse(v)}
        case 7:
          var v: Iroha_Protocol_AssetResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .assetResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .assetResponse(v)}
        case 8:
          var v: Iroha_Protocol_RolesResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .rolesResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .rolesResponse(v)}
        case 9:
          var v: Iroha_Protocol_RolePermissionsResponse?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .rolePermissionsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .rolePermissionsResponse(v)}
        case 10: try decoder.decodeSingularBytesField(value: &_storage._queryHash)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._response {
      case .accountAssetsResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .accountDetailResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .accountResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .errorResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .signatoriesResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .transactionsResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .assetResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .rolesResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .rolePermissionsResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case nil: break
      }
      if !_storage._queryHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._queryHash, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iroha.protocol"

extension Iroha_Protocol_Asset: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "domain_id"),
    3: .same(proto: "precision"),
  ]

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_Asset) -> Bool {
    if self.assetID != other.assetID {return false}
    if self.domainID != other.domainID {return false}
    if self.precision != other.precision {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_Account: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "domain_id"),
    3: .same(proto: "quorum"),
    4: .standard(proto: "json_data"),
  ]

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_Account) -> Bool {
    if self.accountID != other.accountID {return false}
    if self.domainID != other.domainID {return false}
    if self.quorum != other.quorum {return false}
    if self.jsonData != other.jsonData {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AccountAsset: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_id"),
    2: .standard(proto: "account_id"),
    3: .same(proto: "balance"),
  ]

  fileprivate class _StorageClass {
    var _assetID: String = String()
    var _accountID: String = String()
    var _balance: Iroha_Protocol_Amount? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _assetID = source._assetID
      _accountID = source._accountID
      _balance = source._balance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AccountAsset) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._assetID != other_storage._assetID {return false}
        if _storage._accountID != other_storage._accountID {return false}
        if _storage._balance != other_storage._balance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AccountAssetResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_asset"),
  ]

  fileprivate class _StorageClass {
    var _accountAsset: Iroha_Protocol_AccountAsset? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountAsset = source._accountAsset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AccountAssetResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._accountAsset != other_storage._accountAsset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AccountDetailResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "detail"),
  ]

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AccountDetailResponse) -> Bool {
    if self.detail != other.detail {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AccountResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "account_roles"),
  ]

  fileprivate class _StorageClass {
    var _account: Iroha_Protocol_Account? = nil
    var _accountRoles: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _accountRoles = source._accountRoles
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AccountResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._account != other_storage._account {return false}
        if _storage._accountRoles != other_storage._accountRoles {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_AssetResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
  ]

  fileprivate class _StorageClass {
    var _asset: Iroha_Protocol_Asset? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _asset = source._asset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_AssetResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._asset != other_storage._asset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_RolesResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
  ]

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_RolesResponse) -> Bool {
    if self.roles != other.roles {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_RolePermissionsResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
  ]

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_RolePermissionsResponse) -> Bool {
    if self.permissions != other.permissions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_ErrorResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_ErrorResponse) -> Bool {
    if self.reason != other.reason {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_ErrorResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATELESS_INVALID"),
    1: .same(proto: "STATEFUL_INVALID"),
    2: .same(proto: "NO_ACCOUNT"),
    3: .same(proto: "NO_ACCOUNT_ASSETS"),
    4: .same(proto: "NO_ACCOUNT_DETAIL"),
    5: .same(proto: "NO_SIGNATORIES"),
    6: .same(proto: "NOT_SUPPORTED"),
    7: .same(proto: "WRONG_FORMAT"),
    8: .same(proto: "NO_ASSET"),
    9: .same(proto: "NO_ROLES"),
  ]
}

extension Iroha_Protocol_SignatoriesResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_SignatoriesResponse) -> Bool {
    if self.keys != other.keys {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_TransactionsResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_TransactionsResponse) -> Bool {
    if self.transactions != other.transactions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Iroha_Protocol_QueryResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_assets_response"),
    2: .standard(proto: "account_detail_response"),
    3: .standard(proto: "account_response"),
    4: .standard(proto: "error_response"),
    5: .standard(proto: "signatories_response"),
    6: .standard(proto: "transactions_response"),
    7: .standard(proto: "asset_response"),
    8: .standard(proto: "roles_response"),
    9: .standard(proto: "role_permissions_response"),
    10: .standard(proto: "query_hash"),
  ]

  fileprivate class _StorageClass {
    var _response: Iroha_Protocol_QueryResponse.OneOf_Response?
    var _queryHash: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _response = source._response
      _queryHash = source._queryHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Iroha_Protocol_QueryResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._response != other_storage._response {return false}
        if _storage._queryHash != other_storage._queryHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
